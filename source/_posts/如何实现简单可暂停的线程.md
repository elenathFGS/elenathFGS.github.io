---
title: 如何实现简单可暂停的线程
date: 2019-06-06 16:03:21
tags: thread synchronize
categories: thread
---
# 如何实现简单的可暂停线程

## 线程休眠

在多线程程序中，我们可以使用sleep函数来使当前进程休眠指定的时间，而在一些业务逻辑中，需要实现主线程调度各个线程暂停和继续，而不是只能指定sleep时间。

---

## 线程暂停的一些方法

* 使用 suspend 和 resume 实现暂停和恢复

使用suspend和resume方法虽然可以实现线程的暂停和恢复，但是极易出现_**公共的同步对象独占**_和_**数据不同步的情况**_，因此已经被弃用

* 使用yield方法来实现线程暂停

yield方法可以让某个线程放弃当前的CPU资源，让位给其他程序，但是让位的时间不确定，有可能刚刚让位，在下一秒马上又获得CPU时间片

---

## 自己实现线程暂停

可以采用wait()方法配合notify()方法实现自己线程的暂停和恢复

* wait()

wait()方法的作用是让当前的进程进入等待状态，同时wait()还会让当前的进程释放掉已经拥有的锁
这样用一个锁锁住wait()部分的代码，就可以把这个线程的生死大权交给主线程，等待主线程调用notify()方法才可以继续运行，实例代码如下

```java
        synchronized(this) {
          wait();
        }
```

注：因为wait()方法要释放锁，所以一定要放在synchronized里面使用

* notify() / notifyAll()

wait方法使得线程处于阻塞状态，notify() / notifyAll() 方法用来唤醒某个正在wait的进程，至于唤醒哪个线程，和用来锁线程的锁对象有关，比如上面的wait要被唤醒，就得用“this“这个对象(假如this实例叫t1,则为t1.notify，若要全部唤醒，则为ti.notifyAll)

* 一个小demo

```java
  class thread implements Runnable {

    int id;
    boolean suspend = true;

    public thread(int id) {
        this.id = id;
    }

    //调用continu方法来继续运行线程
    synchronized void continu() {
        suspend = false;
        notify();
    }

    @Override
    public void run() {
        while(true) {
            suspend = true;
            try {
                synchronized(this) {
                    if (suspend) {
                        wait();
                    }
                }
            } catch(InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (Test.o) {
            //实现一些操作，每一轮调用实现一次这些操作
                System.out.println(id);
            }
        }
    }
}
```

